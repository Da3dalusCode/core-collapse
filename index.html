<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Core Collapse</title>
  <style>
    html, body { margin: 0; padding: 0; background: #000; overflow: hidden; }
    canvas { display: block; background: radial-gradient(circle at center, #101018 0%, #000 70%); }
    .noselect { user-select: none; -webkit-user-select: none; -ms-user-select: none; }
  </style>
</head>
<body class="noselect">
<canvas id="game"></canvas>
<script>
// =============================
// Core Collapse â€” Canvas Game (Cloudflare Workers Leaderboard)
// =============================
// This build uses your Worker API for the global leaderboard.
// Endpoint you gave: core-collapse-leaderboard.colours256.workers.dev

// ---------- Config ----------
let MIN_SUBMIT_SCORE = 300;                 // threshold to show "Submit score" button
const API_BASE = 'https://core-collapse-leaderboard.colours256.workers.dev';

// Debug mode toggled by appending '?debug=1' to the page URL
const DEBUG = new URLSearchParams(location.search).has('debug');
if (DEBUG) MIN_SUBMIT_SCORE = 0; // always show Submit in debug

// Gameplay params
const ENERGY_PER_ORB = 15;
const ENERGY_GAIN_THRESHOLD = 30; // collect ~2 orbs to advance wave
const INTERWAVE_MS = 2000;
const NOSE_OFFSET = 28;            // distance from ship center to nose

// ---------- Canvas Setup ----------
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resize); resize();

// ---------- State ----------
let gameState = 'menu'; // 'menu' | 'playing' | 'interwave' | 'gameover'
let energy = 60;                 // start below cap so pickups matter immediately
let wave = 1;
let lastTime = performance.now();
let elapsed = 0; // ms
let enemySpawnTimer = 0; // ms accumulator
let gameOverAt = null; // timestamp when death occurs
let waveStartAt = performance.now();
let showWaveBannerFor = 1200; // ms
let interwaveEndAt = 0; let nextWave = 0;

// Aiming
let mouseX = canvas.width / 2, mouseY = canvas.height / 2;
let prevMouseX = mouseX, prevMouseY = mouseY; let aimAngle = 0; let spaceHeld = false;

// Entities
const stars = []; const playerBullets = []; const enemies = []; const enemyBullets = [];
const explosions = []; const exhaustParticles = []; const energyOrbs = [];

// Scores
let kills = 0; let energyCollected = 0; let lastFinalScore = 0; let lastFinalWave = 1; let lastFinalKills = 0; let lastFinalEnergy = 0;
let globalScores = [];

// Buttons (for menu and game over)
let startBtn = null; let replayBtn = null; let submitBtn = null; let testBtn = null; // test button appears only in DEBUG

// ---------- Helpers ----------
function rand(min, max){ return Math.random() * (max - min) + min; }
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
function dist(a,b,x,y){ const dx=a-x, dy=b-y; return Math.hypot(dx,dy); }

// ---------- Global Leaderboard (Cloudflare Worker) ----------
async function loadGlobalScores(){
  try {
    const res = await fetch(`${API_BASE}/scores?limit=10&seed=${Date.now()}`, { cache: 'no-store' });
    if (res.ok) {
      const data = await res.json();
      if (Array.isArray(data)) {
        globalScores = data;
      } else if (data && Array.isArray(data.top)) {
        globalScores = data.top;
      }
      // Ensure sorted just in case
      globalScores.sort((a,b)=> (b.score||0) - (a.score||0));
    }
  } catch (e) { /* ignore network errors */ }
}
loadGlobalScores();

// ---------- Background Stars ----------
function initStars() {
  stars.length = 0;
  const count = Math.floor((canvas.width * canvas.height) / 8000); // scale with screen
  for (let i = 0; i < count; i++) {
    stars.push({ x: Math.random()*canvas.width, y: Math.random()*canvas.height, size: Math.random()*1.6+0.2, speed: Math.random()*0.6+0.15 });
  }
}
initStars();

function drawStars(dt){
  ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
  for (const s of stars){
    s.x -= s.speed * (dt/16.67); if (s.x < 0) s.x = canvas.width;
    ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fillStyle = '#fff'; ctx.fill();
  }
}

// ---------- Ship ----------
const ship = {
  x: canvas.width/2, y: canvas.height/2, angle: 0, fireCooldown: 0,
  update(dt){
    // Nose at mouse; center trails behind nose by NOSE_OFFSET
    const dx = mouseX - prevMouseX, dy = mouseY - prevMouseY;
    if (Math.hypot(dx,dy) > 0.5) { aimAngle = Math.atan2(dy, dx); }
    this.angle = aimAngle;
    const noseX = mouseX, noseY = mouseY;
    this.x = noseX - Math.cos(this.angle) * NOSE_OFFSET;
    this.y = noseY - Math.sin(this.angle) * NOSE_OFFSET;

    // Shooting
    if (spaceHeld && this.fireCooldown <= 0){
      const speed = 8; playerBullets.push({ x: noseX, y: noseY, vx: Math.cos(this.angle)*speed, vy: Math.sin(this.angle)*speed, r: 4 });
      this.fireCooldown = 90; // ms
    } else { this.fireCooldown = Math.max(0, this.fireCooldown - dt); }

    // Exhaust particles from tail
    const tailX = this.x - Math.cos(this.angle)*8, tailY = this.y - Math.sin(this.angle)*8;
    exhaustParticles.push({ x: tailX, y: tailY, vx: -Math.cos(this.angle)*0.2 + rand(-0.3,0.3), vy: -Math.sin(this.angle)*0.2 + rand(-0.3,0.3), r: rand(1,2.5), life: 400 });
  },
  draw(){
    ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
    // hull
    ctx.beginPath(); ctx.moveTo(NOSE_OFFSET, 0); ctx.lineTo(-18, -12); ctx.lineTo(-8, 0); ctx.lineTo(-18, 12); ctx.closePath();
    ctx.fillStyle = '#00f0ff'; ctx.shadowBlur = 24; ctx.shadowColor = '#00eaff'; ctx.fill();
    // cockpit glow
    ctx.beginPath(); ctx.arc(-2,0,3,0,Math.PI*2); ctx.fillStyle = '#7ef9ff'; ctx.shadowBlur = 18; ctx.fill(); ctx.shadowBlur = 0; ctx.restore();
    // crosshair at mouse
    ctx.save(); ctx.translate(mouseX, mouseY); ctx.globalAlpha = 0.85;
    ctx.beginPath(); ctx.arc(0,0,6,0,Math.PI*2); ctx.strokeStyle = '#66ffff'; ctx.lineWidth = 1.5; ctx.stroke();
    ctx.beginPath(); ctx.moveTo(-10,0); ctx.lineTo(-4,0); ctx.moveTo(4,0); ctx.lineTo(10,0); ctx.moveTo(0,-10); ctx.lineTo(0,-4); ctx.moveTo(0,4); ctx.lineTo(0,10); ctx.stroke();
    ctx.globalAlpha = 1; ctx.restore();
  }
};

// ---------- Energy Orbs ----------
function spawnEnergyOrb(x,y){ energyOrbs.push({ x, y, vx: rand(-0.6,0.6), vy: rand(-0.6,0.6), r: 6, t: 0 }); }
function updateEnergyOrbs(dt){
  for (let i=energyOrbs.length-1; i>=0; i--){
    const o = energyOrbs[i]; o.t += dt; o.x += o.vx * (dt/16.67); o.y += o.vy * (dt/16.67);
    o.vx *= 0.995; o.vy *= 0.995; // gentle float
    if (dist(o.x,o.y, ship.x, ship.y) < 20){
      energy = Math.min(100, energy + ENERGY_PER_ORB);
      energyCollected += ENERGY_PER_ORB; energyGainedThisWave += ENERGY_PER_ORB;
      energyOrbs.splice(i,1); continue;
    }
    o.x = clamp(o.x, 5, canvas.width-5); o.y = clamp(o.y, 5, canvas.height-5);
  }
}
function drawEnergyOrbs(){
  for (const o of energyOrbs){ const pulse = 0.5 + 0.5*Math.sin(o.t*0.01);
    ctx.beginPath(); ctx.arc(o.x, o.y, o.r + pulse, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(0,255,120,0.85)'; ctx.shadowBlur = 20; ctx.shadowColor = '#00ff99'; ctx.fill(); ctx.shadowBlur = 0; }
}

// ---------- Explosions ----------
function spawnExplosion(x,y){
  const count = 14 + (Math.random()*8|0);
  for (let i=0;i<count;i++){ const ang = Math.random()*Math.PI*2, sp = rand(1.6,3.1);
    explosions.push({ x, y, vx: Math.cos(ang)*sp, vy: Math.sin(ang)*sp, r: rand(3,5), life: 600, hue: (Math.random()*360)|0 });
  }
}
function updateExplosions(dt){
  for (let i=explosions.length-1; i>=0; i--){ const p = explosions[i]; p.life -= dt; if (p.life<=0){ explosions.splice(i,1); continue; }
    p.x += p.vx * (dt/16.67); p.y += p.vy * (dt/16.67); p.r *= 0.985; }
}
function drawExplosions(){
  for (const p of explosions){ ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
    ctx.fillStyle = `hsla(${p.hue},100%,70%,0.7)`; ctx.shadowBlur = 18; ctx.shadowColor = ctx.fillStyle; ctx.fill(); ctx.shadowBlur = 0; }
}

// ---------- Enemies ----------
function spawnEnemy(){
  const side = Math.random(); let x,y; if (side<0.25){ x=0; y=rand(0,canvas.height);} else if (side<0.5){ x=canvas.width; y=rand(0,canvas.height);} else if (side<0.75){ x=rand(0,canvas.width); y=0;} else { x=rand(0,canvas.width); y=canvas.height; }
  const baseSpeed = 0.35 + 0.10*wave; enemies.push({ x, y, r: 18, speed: baseSpeed, fireCd: rand(450,1000) });
}
function spawnInitialEnemiesForWave(){ const initial = clamp(1 + Math.floor(wave/1.5), 1, 4); for (let i=0;i<initial;i++) spawnEnemy(); }
function updateEnemies(dt){
  for (let i=enemies.length-1; i>=0; i--){ const e = enemies[i];
    const dx = ship.x - e.x, dy = ship.y - e.y, d = Math.hypot(dx,dy) || 1;
    e.x += (dx/d) * e.speed * (dt/16.67); e.y += (dy/d) * e.speed * (dt/16.67);
    e.fireCd -= dt; if (e.fireCd<=0){ const ang = Math.atan2(ship.y - e.y, ship.x - e.x); const sp = 3.8 + 0.2*wave; // slightly slower
      enemyBullets.push({ x:e.x, y:e.y, vx:Math.cos(ang)*sp, vy:Math.sin(ang)*sp, r:4 }); e.fireCd = rand(800,1300) / Math.max(1, (0.85 + 0.12*wave)); }
    if (dist(e.x,e.y,ship.x,ship.y) < e.r + 16){ energy -= 20; spawnExplosion(e.x,e.y); spawnEnergyOrb(e.x,e.y); enemies.splice(i,1); continue; }
  }
}
function drawEnemies(){
  for (const e of enemies){ ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,Math.PI*2); ctx.fillStyle = '#ff8c00'; ctx.shadowBlur = 16; ctx.shadowColor = '#ff8c00'; ctx.fill(); ctx.shadowBlur = 0; ctx.beginPath(); ctx.arc(e.x, e.y, 4, 0, Math.PI*2); ctx.fillStyle = '#fff'; ctx.fill(); }
}

// ---------- Bullets ----------
function updatePlayerBullets(dt){
  for (let i=playerBullets.length-1;i>=0;i--){ const b = playerBullets[i]; b.x += b.vx * (dt/16.67); b.y += b.vy * (dt/16.67);
    for (let j=enemies.length-1;j>=0;j--){ const e = enemies[j]; if (dist(b.x,b.y,e.x,e.y) < b.r + e.r){
        spawnExplosion(e.x,e.y); spawnEnergyOrb(e.x,e.y); enemies.splice(j,1); playerBullets.splice(i,1); kills++; break; } }
    if (b.x< -10||b.x>canvas.width+10||b.y<-10||b.y>canvas.height+10){ playerBullets.splice(i,1); }
  }
}
function drawPlayerBullets(){ ctx.fillStyle = '#7ef9ff'; for (const b of playerBullets){ ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.shadowBlur=12; ctx.shadowColor='#7ef9ff'; ctx.fill(); ctx.shadowBlur=0; } }
function updateEnemyBullets(dt){
  for (let i=enemyBullets.length-1;i>=0;i--){ const b = enemyBullets[i]; b.x += b.vx * (dt/16.67); b.y += b.vy * (dt/16.67);
    if (dist(b.x,b.y,ship.x,ship.y) < b.r + 14){ energy -= 10; enemyBullets.splice(i,1); continue; }
    if (b.x< -10||b.x>canvas.width+10||b.y<-10||b.y>canvas.height+10){ enemyBullets.splice(i,1); }
  }
}
function drawEnemyBullets(){ ctx.fillStyle = '#ff3b3b'; for (const b of enemyBullets){ ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.shadowBlur=12; ctx.shadowColor='#ff3b3b'; ctx.fill(); ctx.shadowBlur=0; } }

// ---------- Waves & Spawning ----------
let energyGainedThisWave = 0;
function resetWaveTimers(){ enemySpawnTimer = 0; waveStartAt = performance.now(); energyGainedThisWave = 0; spawnInitialEnemiesForWave(); }
function enterInterwave(){ enemies.length = 0; enemyBullets.length = 0; playerBullets.length = 0; energyOrbs.length = 0; gameState = 'interwave'; interwaveEndAt = performance.now() + INTERWAVE_MS; }
function updateWaves(dt){
  const spawnInterval = clamp(1800 - (wave-1)*150, 900, 1800); enemySpawnTimer += dt; if (enemySpawnTimer >= spawnInterval){ enemySpawnTimer = 0; spawnEnemy(); }
  if (energyGainedThisWave >= ENERGY_GAIN_THRESHOLD){ nextWave = wave + 1; enterInterwave(); }
}
function drawWaveBanner(){ const t = performance.now() - waveStartAt; if (t < showWaveBannerFor){ const alpha = 1 - (t / showWaveBannerFor); ctx.save(); ctx.globalAlpha = clamp(alpha,0,1); ctx.font = 'bold 38px sans-serif'; ctx.fillStyle = '#00eaff'; const text = `WAVE ${wave}`; const w = ctx.measureText(text).width; ctx.fillText(text, (canvas.width - w)/2, 80); ctx.restore(); } }
function drawInterwave(){ drawStars(16.67); ctx.font = 'bold 42px sans-serif'; ctx.fillStyle = '#aaf7ff'; const txt1 = `Wave ${wave} Complete`; let w = ctx.measureText(txt1).width; ctx.fillText(txt1, (canvas.width-w)/2, canvas.height*0.42); ctx.font = 'bold 28px sans-serif'; ctx.fillStyle = '#cfffff'; const secs = Math.ceil((interwaveEndAt - performance.now())/1000); const txt2 = `Next: Wave ${nextWave} in ${Math.max(0,secs)}...`; w = ctx.measureText(txt2).width; ctx.fillText(txt2, (canvas.width-w)/2, canvas.height*0.52); if (DEBUG){ ctx.font = '12px monospace'; const dbg = `debug: api=${API_BASE}`; const ww = ctx.measureText(dbg).width; ctx.fillText(dbg, (canvas.width-ww)/2, canvas.height*0.58); } }

// ---------- UI: Menu & Game Over ----------
function drawTitle(text, y){ ctx.font = '900 72px sans-serif'; ctx.fillStyle = '#7ef9ff'; ctx.shadowBlur=28; ctx.shadowColor='#00eaff'; const w = ctx.measureText(text).width; ctx.fillText(text, (canvas.width - w)/2, y); ctx.shadowBlur=0; }
function drawButton(label, cx, cy){ const paddingX = 28; ctx.font = 'bold 24px sans-serif'; const w = ctx.measureText(label).width + paddingX*2; const h = 54; const x = cx - w/2, y = cy - h/2; ctx.fillStyle = '#0b1b22aa'; ctx.fillRect(x, y, w, h); ctx.strokeStyle = '#00eaff'; ctx.lineWidth = 2; ctx.strokeRect(x+1, y+1, w-2, h-2); ctx.fillStyle = '#cfffff'; const tw = ctx.measureText(label).width; ctx.fillText(label, cx - tw/2, cy + 8); return {x,y,w,h}; }
function drawMenu(){ drawStars(16.67); drawTitle('CORE COLLAPSE', Math.max(110, canvas.height*0.22)); ctx.font = '18px monospace'; ctx.fillStyle = '#d2ffff'; const lines = ['Move: Mouse (cursor = ship nose)','Shoot: Spacebar','Collect green energy orbs; avoid enemy bullets','Advance waves by collecting energy.']; let y = canvas.height*0.32; const lineH = 26; const w = 480; const x = (canvas.width - w)/2; for (const ln of lines){ ctx.fillText(ln, x, y); y += lineH; }
  // Leaderboard (global only)
  const topY = y + 10; const maxShow = 10;
  ctx.font = 'bold 18px monospace'; ctx.fillStyle = '#aaf7ff';
  const head = 'Global High Scores'; let hw = ctx.measureText(head).width; ctx.fillText(head, (canvas.width - hw)/2, topY);
  ctx.fillStyle = '#eaffff'; ctx.font = '16px monospace';
  if (globalScores && globalScores.length){
    for (let i=0;i<Math.min(maxShow, globalScores.length); i++){
      const s = globalScores[i]; const line = `${i+1}. ${s.name || 'Anon'} â€” ${s.score}`; const lw = ctx.measureText(line).width;
      ctx.fillText(line, (canvas.width - lw)/2, topY + 22*(i+1));
    }
  } else {
    const msg='(Appears after first submit)'; const mw = ctx.measureText(msg).width;
    ctx.fillText(msg, (canvas.width - mw)/2, topY + 22);
  }
  startBtn = drawButton('Start', canvas.width/2, Math.min(canvas.height*0.60, canvas.height-140));
  testBtn = null;
  if (DEBUG){ testBtn = drawButton('Test API (debug)', canvas.width/2, Math.min(canvas.height*0.60, canvas.height-140) + 80); ctx.font='12px monospace'; const info = `debug: api=${API_BASE}`; const iw = ctx.measureText(info).width; ctx.fillText(info, (canvas.width - iw)/2, canvas.height*0.60 + 130); }
}
function drawHUD(){ const bw = 200, bh = 14, x = 20, y = 20; ctx.fillStyle = '#223'; ctx.fillRect(x,y,bw,bh); ctx.fillStyle = '#00ffa0'; ctx.fillRect(x,y, bw*(energy/100), bh); ctx.strokeStyle = '#66ffff'; ctx.lineWidth = 1; ctx.strokeRect(x,y,bw,bh); ctx.font = '14px monospace'; ctx.fillStyle = '#cfffff'; ctx.fillText(`Energy: ${Math.floor(energy)}`, x, y+bh+14); ctx.fillText(`Wave ${wave}`, x, y+bh+30); ctx.fillText(`Kills ${kills}`, x, y+bh+46); }
function drawGameOver(){ drawStars(16.67); const t = performance.now() - gameOverAt; if (t < 1800){ const a = clamp(t/800, 0, 1); ctx.save(); ctx.globalAlpha = a; ctx.font = 'bold 64px sans-serif'; ctx.fillStyle = '#ff7b7b'; const txt = 'GAME OVER'; const w = ctx.measureText(txt).width; ctx.fillText(txt, (canvas.width-w)/2, canvas.height*0.40); ctx.restore(); } if (t > 1200){ const a = clamp((t-1200)/800, 0, 1); ctx.save(); ctx.globalAlpha = a; ctx.font = '900 96px sans-serif'; ctx.fillStyle = '#ffffff'; const txt = 'SLAMMED'; const w = ctx.measureText(txt).width; ctx.fillText(txt, (canvas.width-w)/2, canvas.height*0.55); ctx.restore(); }
  // Final score
  ctx.font = 'bold 22px monospace'; ctx.fillStyle = '#cfffff'; const st = `Score ${lastFinalScore}  â€¢  Wave ${lastFinalWave}  â€¢  Kills ${lastFinalKills}`; let w = ctx.measureText(st).width; ctx.fillText(st, (canvas.width-w)/2, canvas.height*0.64);
  // Buttons
  replayBtn = drawButton('Play Again', canvas.width/2, canvas.height*0.74);
  submitBtn = null; if (lastFinalScore >= MIN_SUBMIT_SCORE){ submitBtn = drawButton('Submit score', canvas.width/2, canvas.height*0.82); }
}
function pointInRect(px,py, r){ return r && px>=r.x && px<=r.x+r.w && py>=r.y && py<=r.y+r.h; }

// ---------- Reset & Scoring ----------
function computeFinalScore(){ return Math.max(0, Math.floor(wave*100 + kills*25 + energyCollected*1)); }
function resetGame(){ enemies.length = 0; enemyBullets.length = 0; playerBullets.length = 0; explosions.length = 0; exhaustParticles.length = 0; energyOrbs.length = 0; energy = 60; wave = 1; gameOverAt = null; energyGainedThisWave = 0; kills = 0; energyCollected = 0; ship.x = canvas.width/2; ship.y = canvas.height/2; aimAngle = 0; mouseX = ship.x + NOSE_OFFSET; mouseY = ship.y; prevMouseX = mouseX; prevMouseY = mouseY; resetWaveTimers(); }

// ---------- Main Loop ----------
function loop(ts){ const dt = Math.min(48, ts - lastTime); lastTime = ts; elapsed += dt;
  if (gameState === 'menu'){ drawMenu(); requestAnimationFrame(loop); return; }
  if (gameState === 'gameover'){ drawGameOver(); requestAnimationFrame(loop); return; }
  if (gameState === 'interwave'){ drawInterwave(); if (performance.now() >= interwaveEndAt){ wave = nextWave; resetWaveTimers(); gameState = 'playing'; } requestAnimationFrame(loop); return; }
  // PLAYING
  drawStars(dt); const g = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, Math.max(canvas.width,canvas.height)/1.4); g.addColorStop(0, `rgba(20,30,40,${0.2 + 0.15*Math.sin(elapsed*0.002)})`); g.addColorStop(1, 'transparent'); ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);
  ship.update(dt); updatePlayerBullets(dt); updateEnemyBullets(dt); updateEnemies(dt); updateExplosions(dt); updateEnergyOrbs(dt);
  drawEnemies(); drawEnemyBullets(); drawPlayerBullets(); drawExplosions(); drawEnergyOrbs();
  for (let i=exhaustParticles.length-1; i>=0; i--){ const p = exhaustParticles[i]; p.life -= dt; if (p.life<=0){ exhaustParticles.splice(i,1); continue; } p.x += p.vx * (dt/16.67); p.y += p.vy * (dt/16.67); p.r *= 0.985; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fillStyle='rgba(0,255,255,0.35)'; ctx.shadowBlur=10; ctx.shadowColor='#00eaff'; ctx.fill(); ctx.shadowBlur=0; }
  ship.draw(); drawHUD(); drawWaveBanner();
  updateWaves(dt);
  if (energy <= 0){ gameState = 'gameover'; gameOverAt = performance.now(); lastFinalWave = wave; lastFinalKills = kills; lastFinalEnergy = energyCollected; lastFinalScore = computeFinalScore(); enemies.length = 0; enemyBullets.length = 0; playerBullets.length = 0; energyOrbs.length = 0; explosions.length = 0; exhaustParticles.length = 0; }
  requestAnimationFrame(loop); }

// ---------- Input ----------
canvas.addEventListener('mousemove', e=>{ prevMouseX = mouseX; prevMouseY = mouseY; mouseX = e.clientX; mouseY = e.clientY; });
document.addEventListener('keydown', e=>{ if (e.code==='Space') spaceHeld = true; });
document.addEventListener('keyup',   e=>{ if (e.code==='Space') spaceHeld = false; });
canvas.addEventListener('click', async e=>{ const x=e.clientX, y=e.clientY; if (gameState==='menu'){
    if (startBtn && pointInRect(x,y,startBtn)){ gameState='playing'; resetGame(); return; }
    if (DEBUG && testBtn && pointInRect(x,y,testBtn)){
      // Quick POST to verify API wiring
      try{
        const res = await fetch(`${API_BASE}/scores`, { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({ name:'Debug', score:123, wave:1, kills:0, energy:0 }) });
        const data = await res.json();
        alert(res.ok ? 'API OK' : `API error: ${data && data.reason}`);
        await loadGlobalScores();
      }catch{ alert('API unreachable'); }
      return;
    }
  }
  if (gameState==='gameover'){
    if (replayBtn && pointInRect(x,y,replayBtn)){ gameState='playing'; resetGame(); return; }
    if (submitBtn && pointInRect(x,y,submitBtn)){
      const name = (prompt('High score! Enter your name:')||'Anonymous').trim().slice(0,24); if(!name) return; // save locally
            try {
        const res = await fetch(`${API_BASE}/scores`, {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ name, score: lastFinalScore, wave: lastFinalWave, kills: lastFinalKills, energy: lastFinalEnergy })
        });
        const data = await res.json().catch(()=>null);
        console.log('Submit response', res.status, data);
        if (res.ok && data && Array.isArray(data.top)) {
          globalScores = data.top; // immediate update
          alert('Score submitted!');
        } else {
          alert(`Submitted locally. Global board unavailable.${data && data.reason ? ` (${data.reason})` : ''}`);
        }
      } catch (err) {
        console.error('Submit error', err);
        alert('Submitted locally. Global board unavailable. (network)');
      }
      return;
    }
  }
});

// ---------- Kickoff ----------
resetGame(); requestAnimationFrame(loop);
</script>
</body>
</html>
